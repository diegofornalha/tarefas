import {
  writable
} from "./chunk-C5ENZSNN.js";
import {
  fade,
  scale
} from "./chunk-GIFAGFJN.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_dev,
  append_styles,
  attr_dev,
  check_outros,
  component_subscribe,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_in_transition,
  create_out_transition,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  globals,
  group_outros,
  init,
  insert_dev,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  prevent_default,
  safe_not_equal,
  set_data_dev,
  space,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-2SWUXKJS.js";
import "./chunk-TWLJ45QX.js";

// node_modules/svelte-easy-toast/core/toast.store.js
var createStore = () => {
  const { subscribe, set, update } = writable([]);
  const generateUniqueId = () => {
    const time = Date.now();
    const randomNumber = Math.random();
    return time.toString() + randomNumber.toString();
  };
  const push = (option) => {
    return update((options) => [
      ...options,
      { ...option, id: generateUniqueId() }
    ]);
  };
  const onPushed = (callback) => {
    const subscription = subscribe((items) => {
      if (Array.isArray(items) && items.length) {
        callback(items[items.length - 1]);
      }
    });
    return subscription;
  };
  const remove = (id) => {
    return update((options) => options.filter((item) => item.id !== id));
  };
  return { subscribe, update, set, push, onPushed, generateUniqueId, remove };
};
var toast_store_default = createStore();

// node_modules/svelte-easy-toast/components/SvelteToastItem.svelte
var file = "node_modules/svelte-easy-toast/components/SvelteToastItem.svelte";
function add_css(target) {
  append_styles(target, "svelte-wnc5dv", ".svelte-et-alert.svelte-wnc5dv{--svelte-et-padding:15px;--svelte-et-border-radius:5px;--svelte-et-default-color:#636464;--svelte-et-default-bg:#fefefe;--svelte-et-default-border-color:#fdfdfe;--svelte-et-primary-color:#084298;--svelte-et-primary-bg:#cfe2ff;--svelte-et-primary-border-color:#b6d4fe;--svelte-et-dark-color:#141619;--svelte-et-dark-bg:#d3d3d4;--svelte-et-dark-border-color:#bcbebf;--svelte-et-info-color:#055160;--svelte-et-info-bg:#cff4fc;--svelte-et-info-border-color:#b6effb;--svelte-et-success-color:#0f5132;--svelte-et-success-bg:#d1e7dd;--svelte-et-success-border-color:#badbcc;--svelte-et-warning-color:#664d03;--svelte-et-warning-bg:#fff3cd;--svelte-et-warning-border-color:#ffecb5;--svelte-et-error-color:#842029;--svelte-et-error-bg:#f8d7da;--svelte-et-error-border-color:#f5c2c7;color:inherit;font-family:inherit;border:solid 1px;border-radius:var(--svelte-et-border-radius);display:block;z-index:10000;max-width:100%;pointer-events:visible;will-change:transform;box-shadow:0 0.125rem 0.25rem rgba(0, 0, 0, 0.075)}@media(min-width: 576px){.svelte-et-alert.svelte-wnc5dv{min-width:200px;max-width:300px}}.svelte-et-alert-content.svelte-wnc5dv{position:relative;display:flex;flex-direction:column;padding-top:var(--svelte-et-padding)}.svelte-et-header.svelte-wnc5dv{display:flex;align-items:center;padding-left:var(--svelte-et-padding);padding-right:var(--svelte-et-padding);padding-bottom:5px}.svelte-et-title.svelte-wnc5dv{flex-grow:1;font-weight:bold}.svelte-et-text.svelte-wnc5dv{padding-right:var(--svelte-et-padding);padding-left:var(--svelte-et-padding);padding-bottom:var(--svelte-et-padding);overflow-wrap:break-word}.svelte-et-alert-primary.svelte-wnc5dv{color:var(--svelte-et-primary-color);background-color:var(--svelte-et-primary-bg);border-color:var(--svelte-et-primary-border-color)}.svelte-et-alert-dark.svelte-wnc5dv{color:var(--svelte-et-dark-color);background-color:var(--svelte-et-dark-bg);border-color:var(--svelte-et-dark-border-color)}.svelte-et-alert-default.svelte-wnc5dv{color:var(--svelte-et-default-color);background-color:var(--svelte-et-default-bg);border-color:var(--svelte-et-default-border-color)}.svelte-et-alert-info.svelte-wnc5dv{color:var(--svelte-et-info-color);background-color:var(--svelte-et-info-bg);border-color:var(--svelte-et-info-border-color)}.svelte-et-alert-success.svelte-wnc5dv{color:var(--svelte-et-success-color);background-color:var(--svelte-et-success-bg);border-color:var(--svelte-et-success-border-color)}.svelte-et-alert-warning.svelte-wnc5dv{color:var(--svelte-et-warning-color);background-color:var(--svelte-et-warning-bg);border-color:var(--svelte-et-warning-border-color)}.svelte-et-alert-error.svelte-wnc5dv{color:var(--svelte-et-error-color);background-color:var(--svelte-et-error-bg);border-color:var(--svelte-et-error-border-color)}.svelte-et-close.svelte-wnc5dv{right:10px;top:10px;width:16px;height:16px;opacity:0.3;cursor:pointer;pointer-events:visible;font-size:0px;position:absolute}.svelte-et-close.svelte-wnc5dv:hover{opacity:1}.svelte-et-close.svelte-wnc5dv:before,.svelte-et-close.svelte-wnc5dv:after{position:absolute;left:7px;content:' ';height:16px;width:2px;background-color:#333}.svelte-et-close.svelte-wnc5dv:before{transform:rotate(45deg)}.svelte-et-close.svelte-wnc5dv:after{transform:rotate(-45deg)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZlbHRlVG9hc3RJdGVtLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9mbG93L0Rlc2t0b3AvRGVza3RvcC9zdmVsdGUvbm9kZV9tb2R1bGVzL3N2ZWx0ZS1lYXN5LXRvYXN0L2NvbXBvbmVudHMvU3ZlbHRlVG9hc3RJdGVtLnN2ZWx0ZSJdfQ== */");
}
function create_if_block_1(ctx) {
  let div1;
  let div0;
  let t_value = (ctx[0].title || "") + "";
  let t;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t = text(t_value);
      attr_dev(div0, "class", "svelte-et-title svelte-wnc5dv");
      add_location(div0, file, 31, 4, 991);
      attr_dev(div1, "class", "svelte-et-header svelte-wnc5dv");
      add_location(div1, file, 30, 3, 955);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div0, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = (ctx2[0].title || "") + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(30:2) {#if item.title}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let a;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      a = element("a");
      a.textContent = "x";
      attr_dev(a, "href", "/");
      attr_dev(a, "class", "svelte-et-close svelte-wnc5dv");
      add_location(a, file, 37, 3, 1106);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (!mounted) {
        dispose = listen_dev(a, "click", prevent_default(ctx[1]), false, true, false, false);
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(37:2) {#if item.showClose}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div2;
  let div1;
  let t0;
  let t1;
  let div0;
  let t2_value = ctx[0].text + "";
  let t2;
  let div2_intro;
  let div2_outro;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[0].title && create_if_block_1(ctx);
  let if_block1 = ctx[0].showClose && create_if_block(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      t2 = text(t2_value);
      attr_dev(div0, "class", "svelte-et-text svelte-wnc5dv");
      add_location(div0, file, 39, 2, 1199);
      attr_dev(div1, "class", "svelte-et-alert-content svelte-wnc5dv");
      add_location(div1, file, 28, 1, 867);
      attr_dev(div2, "class", "svelte-et-alert svelte-wnc5dv");
      toggle_class(div2, "svelte-et-alert-primary", ctx[0].type === "primary");
      toggle_class(div2, "svelte-et-alert-dark", ctx[0].type === "dark");
      toggle_class(div2, "svelte-et-alert-default", ctx[0].type === "default");
      toggle_class(div2, "svelte-et-alert-info", ctx[0].type === "info");
      toggle_class(div2, "svelte-et-alert-success", ctx[0].type === "success");
      toggle_class(div2, "svelte-et-alert-warning", ctx[0].type === "warning");
      toggle_class(div2, "svelte-et-alert-error", ctx[0].type === "error");
      add_location(div2, file, 15, 0, 360);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t1);
      append_dev(div1, div0);
      append_dev(div0, t2);
      current = true;
      if (!mounted) {
        dispose = listen_dev(div1, "click", ctx[2], false, false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0].title) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0].showClose) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0].text + ""))
        set_data_dev(t2, t2_value);
      if (!current || dirty & 1) {
        toggle_class(div2, "svelte-et-alert-primary", ctx2[0].type === "primary");
      }
      if (!current || dirty & 1) {
        toggle_class(div2, "svelte-et-alert-dark", ctx2[0].type === "dark");
      }
      if (!current || dirty & 1) {
        toggle_class(div2, "svelte-et-alert-default", ctx2[0].type === "default");
      }
      if (!current || dirty & 1) {
        toggle_class(div2, "svelte-et-alert-info", ctx2[0].type === "info");
      }
      if (!current || dirty & 1) {
        toggle_class(div2, "svelte-et-alert-success", ctx2[0].type === "success");
      }
      if (!current || dirty & 1) {
        toggle_class(div2, "svelte-et-alert-warning", ctx2[0].type === "warning");
      }
      if (!current || dirty & 1) {
        toggle_class(div2, "svelte-et-alert-error", ctx2[0].type === "error");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (div2_outro)
          div2_outro.end(1);
        div2_intro = create_in_transition(div2, scale, {});
        div2_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (div2_intro)
        div2_intro.invalidate();
      div2_outro = create_out_transition(div2, fade, {});
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteToastItem", slots, []);
  const dispatch = createEventDispatcher();
  let { item } = $$props;
  const onClickClose = () => {
    dispatch("close", item);
  };
  const onClickContent = (evt) => {
    if (item.closeOnClick) {
      evt.stopPropagation();
      dispatch("close", item);
    }
  };
  $$self.$$.on_mount.push(function() {
    if (item === void 0 && !("item" in $$props || $$self.$$.bound[$$self.$$.props["item"]])) {
      console.warn("<SvelteToastItem> was created without expected prop 'item'");
    }
  });
  const writable_props = ["item"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SvelteToastItem> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    fade,
    scale,
    dispatch,
    item,
    onClickClose,
    onClickContent
  });
  $$self.$inject_state = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [item, onClickClose, onClickContent];
}
var SvelteToastItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { item: 0 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteToastItem",
      options,
      id: create_fragment.name
    });
  }
  get item() {
    throw new Error("<SvelteToastItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value) {
    throw new Error("<SvelteToastItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvelteToastItem_default = SvelteToastItem;

// node_modules/svelte-easy-toast/components/SvelteEasyToast.svelte
var { Object: Object_1 } = globals;
var file2 = "node_modules/svelte-easy-toast/components/SvelteEasyToast.svelte";
function add_css2(target) {
  append_styles(target, "svelte-89e826", ".svelte-et.svelte-89e826{--svelte-et-offset:16px;--svelte-et-zindex:9999;position:fixed;z-index:var(--svelte-et-zindex);top:var(--svelte-et-offset);left:var(--svelte-et-offset);right:var(--svelte-et-offset);bottom:var(--svelte-et-offset);pointer-events:none;display:flex}.svelte-et-top.svelte-89e826 .svelte-et-alert{margin-bottom:var(--svelte-et-offset)}.svelte-et-top-left.svelte-89e826{align-items:flex-start;justify-content:flex-end;flex-direction:column-reverse}.svelte-et-top-right.svelte-89e826{align-items:flex-end;justify-content:flex-end;flex-direction:column-reverse}.svelte-et-top-center.svelte-89e826{align-items:center;justify-content:flex-end;flex-direction:column-reverse}.svelte-et-bottom.svelte-89e826 .svelte-et-alert{margin-top:var(--svelte-et-offset)}.svelte-et-bottom-left.svelte-89e826{align-items:flex-start;justify-content:flex-end;flex-direction:column}.svelte-et-bottom-right.svelte-89e826{align-items:flex-end;justify-content:flex-end;flex-direction:column}.svelte-et-bottom-center.svelte-89e826{align-items:center;justify-content:flex-end;flex-direction:column}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZlbHRlRWFzeVRvYXN0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9mbG93L0Rlc2t0b3AvRGVza3RvcC9zdmVsdGUvbm9kZV9tb2R1bGVzL3N2ZWx0ZS1lYXN5LXRvYXN0L2NvbXBvbmVudHMvU3ZlbHRlRWFzeVRvYXN0LnN2ZWx0ZSJdfQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function create_if_block_10(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_5 = ctx[3];
  validate_each_argument(each_value_5);
  const get_key = (ctx2) => ctx2[21].id;
  validate_each_keys(ctx, each_value_5, get_each_context_5, get_key);
  for (let i = 0; i < each_value_5.length; i += 1) {
    let child_ctx = get_each_context_5(ctx, each_value_5, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_5(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "svelte-et svelte-et-bottom svelte-et-bottom-left svelte-89e826");
      add_location(div, file2, 54, 1, 1590);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 393) {
        each_value_5 = ctx2[3];
        validate_each_argument(each_value_5);
        group_outros();
        validate_each_keys(ctx2, each_value_5, get_each_context_5, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_5, each_1_lookup, div, outro_and_destroy_block, create_each_block_5, null, get_each_context_5);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_5.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(54:0) {#if bottomLeft.length}",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  function close_handler() {
    return ctx[10](ctx[21]);
  }
  var switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default;
  function switch_props(ctx2) {
    return {
      props: { item: ctx2[21] },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on("close", close_handler);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[0] & 8)
        switch_instance_changes.item = ctx[21];
      if (dirty[0] & 8 && switch_value !== (switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          switch_instance.$on("close", close_handler);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(57:3) {#if showing[parseId(item)]}",
    ctx
  });
  return block;
}
function create_each_block_5(key_1, ctx) {
  let first;
  let show_if = ctx[0][ctx[7](ctx[21])];
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_11(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 9)
        show_if = ctx[0][ctx[7](ctx[21])];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 9) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_11(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_5.name,
    type: "each",
    source: "(56:2) {#each bottomLeft as item (item.id)}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_4 = ctx[2];
  validate_each_argument(each_value_4);
  const get_key = (ctx2) => ctx2[21].id;
  validate_each_keys(ctx, each_value_4, get_each_context_4, get_key);
  for (let i = 0; i < each_value_4.length; i += 1) {
    let child_ctx = get_each_context_4(ctx, each_value_4, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_4(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "svelte-et svelte-et-bottom svelte-et-bottom-right svelte-89e826");
      add_location(div, file2, 68, 1, 1954);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 389) {
        each_value_4 = ctx2[2];
        validate_each_argument(each_value_4);
        group_outros();
        validate_each_keys(ctx2, each_value_4, get_each_context_4, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_4, each_1_lookup, div, outro_and_destroy_block, create_each_block_4, null, get_each_context_4);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_4.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(68:0) {#if bottomRight.length}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  function close_handler_1() {
    return ctx[11](ctx[21]);
  }
  var switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default;
  function switch_props(ctx2) {
    return {
      props: { item: ctx2[21] },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on("close", close_handler_1);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[0] & 4)
        switch_instance_changes.item = ctx[21];
      if (dirty[0] & 4 && switch_value !== (switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          switch_instance.$on("close", close_handler_1);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(71:3) {#if showing[parseId(item)]}",
    ctx
  });
  return block;
}
function create_each_block_4(key_1, ctx) {
  let first;
  let show_if = ctx[0][ctx[7](ctx[21])];
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_9(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 5)
        show_if = ctx[0][ctx[7](ctx[21])];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_9(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_4.name,
    type: "each",
    source: "(70:2) {#each bottomRight as item (item.id)}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_3 = ctx[1];
  validate_each_argument(each_value_3);
  const get_key = (ctx2) => ctx2[21].id;
  validate_each_keys(ctx, each_value_3, get_each_context_3, get_key);
  for (let i = 0; i < each_value_3.length; i += 1) {
    let child_ctx = get_each_context_3(ctx, each_value_3, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_3(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "svelte-et svelte-et-bottom svelte-et-bottom-center svelte-89e826");
      add_location(div, file2, 82, 1, 2321);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 387) {
        each_value_3 = ctx2[1];
        validate_each_argument(each_value_3);
        group_outros();
        validate_each_keys(ctx2, each_value_3, get_each_context_3, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_3, each_1_lookup, div, outro_and_destroy_block, create_each_block_3, null, get_each_context_3);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(82:0) {#if bottomCenter.length}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  function close_handler_2() {
    return ctx[12](ctx[21]);
  }
  var switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default;
  function switch_props(ctx2) {
    return {
      props: { item: ctx2[21] },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on("close", close_handler_2);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[0] & 2)
        switch_instance_changes.item = ctx[21];
      if (dirty[0] & 2 && switch_value !== (switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          switch_instance.$on("close", close_handler_2);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(85:3) {#if showing[parseId(item)]}",
    ctx
  });
  return block;
}
function create_each_block_3(key_1, ctx) {
  let first;
  let show_if = ctx[0][ctx[7](ctx[21])];
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_7(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 3)
        show_if = ctx[0][ctx[7](ctx[21])];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(84:2) {#each bottomCenter as item (item.id)}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_2 = ctx[6];
  validate_each_argument(each_value_2);
  const get_key = (ctx2) => ctx2[21].id;
  validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "svelte-et svelte-et-top svelte-et-top-left svelte-89e826");
      add_location(div, file2, 96, 1, 2685);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 449) {
        each_value_2 = ctx2[6];
        validate_each_argument(each_value_2);
        group_outros();
        validate_each_keys(ctx2, each_value_2, get_each_context_2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, div, outro_and_destroy_block, create_each_block_2, null, get_each_context_2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(96:0) {#if topLeft.length}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  function close_handler_3() {
    return ctx[13](ctx[21]);
  }
  var switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default;
  function switch_props(ctx2) {
    return {
      props: { item: ctx2[21] },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on("close", close_handler_3);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[0] & 64)
        switch_instance_changes.item = ctx[21];
      if (dirty[0] & 64 && switch_value !== (switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          switch_instance.$on("close", close_handler_3);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(99:3) {#if showing[parseId(item)]}",
    ctx
  });
  return block;
}
function create_each_block_2(key_1, ctx) {
  let first;
  let show_if = ctx[0][ctx[7](ctx[21])];
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_5(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 65)
        show_if = ctx[0][ctx[7](ctx[21])];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 65) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(98:2) {#each topLeft as item (item.id)}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_1 = ctx[5];
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => ctx2[21].id;
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "svelte-et svelte-et-top svelte-et-top-right svelte-89e826");
      add_location(div, file2, 110, 1, 3037);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 417) {
        each_value_1 = ctx2[5];
        validate_each_argument(each_value_1);
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(110:0) {#if topRight.length}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  function close_handler_4() {
    return ctx[14](ctx[21]);
  }
  var switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default;
  function switch_props(ctx2) {
    return {
      props: { item: ctx2[21] },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on("close", close_handler_4);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[0] & 32)
        switch_instance_changes.item = ctx[21];
      if (dirty[0] & 32 && switch_value !== (switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          switch_instance.$on("close", close_handler_4);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(113:3) {#if showing[parseId(item)]}",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let first;
  let show_if = ctx[0][ctx[7](ctx[21])];
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_3(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 33)
        show_if = ctx[0][ctx[7](ctx[21])];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 33) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(112:2) {#each topRight as item (item.id)}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ctx[4];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[21].id;
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "svelte-et svelte-et-top svelte-et-top-center svelte-89e826");
      add_location(div, file2, 124, 1, 3392);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 401) {
        each_value = ctx2[4];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(124:0) {#if topCenter.length}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  function close_handler_5() {
    return ctx[15](ctx[21]);
  }
  var switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default;
  function switch_props(ctx2) {
    return {
      props: { item: ctx2[21] },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on("close", close_handler_5);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[0] & 16)
        switch_instance_changes.item = ctx[21];
      if (dirty[0] & 16 && switch_value !== (switch_value = ctx[21].customComponent ? ctx[21].customComponent : SvelteToastItem_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          switch_instance.$on("close", close_handler_5);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(127:3) {#if showing[parseId(item)]}",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let show_if = ctx[0][ctx[7](ctx[21])];
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_12(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 17)
        show_if = ctx[0][ctx[7](ctx[21])];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(126:2) {#each topCenter as item (item.id)}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block5_anchor;
  let current;
  let if_block0 = ctx[3].length && create_if_block_10(ctx);
  let if_block1 = ctx[2].length && create_if_block_8(ctx);
  let if_block2 = ctx[1].length && create_if_block_6(ctx);
  let if_block3 = ctx[6].length && create_if_block_4(ctx);
  let if_block4 = ctx[5].length && create_if_block_2(ctx);
  let if_block5 = ctx[4].length && create_if_block2(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_dev(target, t3, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_dev(target, t4, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_dev(target, if_block5_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[3].length) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2].length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_8(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[1].length) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_6(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[6].length) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 64) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_4(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[5].length) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_2(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t4.parentNode, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (ctx2[4].length) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block2(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach_dev(t3);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach_dev(t4);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach_dev(if_block5_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let topLeft;
  let topRight;
  let topCenter;
  let bottomLeft;
  let bottomRight;
  let bottomCenter;
  let $toastStore;
  validate_store(toast_store_default, "toastStore");
  component_subscribe($$self, toast_store_default, ($$value) => $$invalidate(9, $toastStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteEasyToast", slots, []);
  let subscription;
  let timers = {};
  let showing = {};
  const parseId = (option) => (option == null ? void 0 : option.id) || "";
  const showToast = (option) => {
    if (option.id) {
      const id = parseId(option);
      $$invalidate(0, showing[id] = true, showing);
      if (window && window.setTimeout) {
        timers[id] = window.setTimeout(() => closeItem(id), option.delay);
      }
    }
  };
  const subscribe = () => {
    subscription = toast_store_default.onPushed((option) => showToast(option));
  };
  const unsubscribe = () => {
    if (typeof subscription === "function")
      subscription();
    Object.keys(timers).map((key) => {
      if (window && window.clearTimeout) {
        window.clearTimeout(timers[key]);
      }
    });
  };
  const closeItem = (id) => {
    if (typeof id === "string") {
      delete showing[id];
      if (window && window.clearTimeout) {
        window.clearTimeout(timers[id]);
      }
      toast_store_default.remove(id);
    }
  };
  onMount(() => subscribe());
  onDestroy(() => unsubscribe());
  const writable_props = [];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SvelteEasyToast> was created with unknown prop '${key}'`);
  });
  const close_handler = (item) => closeItem(item.id);
  const close_handler_1 = (item) => closeItem(item.id);
  const close_handler_2 = (item) => closeItem(item.id);
  const close_handler_3 = (item) => closeItem(item.id);
  const close_handler_4 = (item) => closeItem(item.id);
  const close_handler_5 = (item) => closeItem(item.id);
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    toastStore: toast_store_default,
    SvelteToastItem: SvelteToastItem_default,
    subscription,
    timers,
    showing,
    parseId,
    showToast,
    subscribe,
    unsubscribe,
    closeItem,
    bottomCenter,
    bottomRight,
    bottomLeft,
    topCenter,
    topRight,
    topLeft,
    $toastStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("subscription" in $$props2)
      subscription = $$props2.subscription;
    if ("timers" in $$props2)
      timers = $$props2.timers;
    if ("showing" in $$props2)
      $$invalidate(0, showing = $$props2.showing);
    if ("bottomCenter" in $$props2)
      $$invalidate(1, bottomCenter = $$props2.bottomCenter);
    if ("bottomRight" in $$props2)
      $$invalidate(2, bottomRight = $$props2.bottomRight);
    if ("bottomLeft" in $$props2)
      $$invalidate(3, bottomLeft = $$props2.bottomLeft);
    if ("topCenter" in $$props2)
      $$invalidate(4, topCenter = $$props2.topCenter);
    if ("topRight" in $$props2)
      $$invalidate(5, topRight = $$props2.topRight);
    if ("topLeft" in $$props2)
      $$invalidate(6, topLeft = $$props2.topLeft);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 512) {
      $:
        $$invalidate(6, topLeft = $toastStore.filter((item) => item.position === "top-left"));
    }
    if ($$self.$$.dirty[0] & 512) {
      $:
        $$invalidate(5, topRight = $toastStore.filter((item) => item.position === "top-right"));
    }
    if ($$self.$$.dirty[0] & 512) {
      $:
        $$invalidate(4, topCenter = $toastStore.filter((item) => item.position === "top-center"));
    }
    if ($$self.$$.dirty[0] & 512) {
      $:
        $$invalidate(3, bottomLeft = $toastStore.filter((item) => item.position === "bottom-left"));
    }
    if ($$self.$$.dirty[0] & 512) {
      $:
        $$invalidate(2, bottomRight = $toastStore.filter((item) => item.position === "bottom-right"));
    }
    if ($$self.$$.dirty[0] & 512) {
      $:
        $$invalidate(1, bottomCenter = $toastStore.filter((item) => item.position === "bottom-center"));
    }
  };
  return [
    showing,
    bottomCenter,
    bottomRight,
    bottomLeft,
    topCenter,
    topRight,
    topLeft,
    parseId,
    closeItem,
    $toastStore,
    close_handler,
    close_handler_1,
    close_handler_2,
    close_handler_3,
    close_handler_4,
    close_handler_5
  ];
}
var SvelteEasyToast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {}, add_css2, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteEasyToast",
      options,
      id: create_fragment2.name
    });
  }
};
var SvelteEasyToast_default = SvelteEasyToast;

// node_modules/svelte-easy-toast/core/toast.js
var defaultOptions = {
  type: "default",
  position: "top-right",
  delay: 2500,
  text: "",
  title: void 0,
  showClose: true,
  closeOnClick: true
};
var toast = (option) => {
  toast_store_default.push({
    ...defaultOptions,
    ...option
  });
};
var toast_default = toast;
export {
  SvelteEasyToast_default as SvelteEasyToast,
  toast_default as toast
};
//# sourceMappingURL=svelte-easy-toast.js.map
